{
  "name": "errati",
  "version": "0.9.1",
  "description": "Errati is a flexible errors index for NodeJS",
  "author": {
    "name": "Mikael Konttinen"
  },
  "license": "BSD",
  "keywords": [
    "error",
    "errors",
    "index",
    "dictionary",
    "http",
    "http errors",
    "http codes"
  ],
  "main": "errati.js",
  "readmeFilename": "README.md",
  "directories": {
    "example": "examples",
    "test": "test"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/smwht/node-errati.git"
  },
  "bugs": {
    "url": "https://github.com/smwht/node-errati/issues"
  },
  "engines": {
    "node": "*"
  },
  "scripts": {
    "test": "echo \"Tests are in ./test\" && exit 1"
  },
  "readme": "# Errati\n\nErrati is a flexible errors index for NodeJS that helps you to use the Node callback pattern to its fullest. It helps the developer to use errors as active messangers that are consistent through the application. \n\nAt its simplest use, it helps you use a standardized set of errors and ease development, debugging and feedback. In more complex use, it enables custom values to be passed in an expected manner, to process errors and take action through the backtracking of callbacks and automatically take appropriate actions when errors are instantiated. \n\nAll of this is done \"define once, use everywhere\" with straight forward Javascript syntax. \n\nErrati is style agnostic and aims to be adapted to the developers needs instead of the other way round. There are no dependencies and no learning curve to speak of. Register your errors from a dictionary (or use the provided HTTP Standard Codes) and you are ready to go.\n\nThe design goals are:\n\n1. Efficiency\n2. Flexibility\n3. Ease of use\n\nUse case example:  \nA module instantiates an error due to a failed user request. The error is populated with default and custom values. It is propagated back through the callback chain where actions may be triggered and additional data is added to the error instace. Finally one set of error data is returned to the user, while another set of data is logged. For severe actions, instantiation is extended with a function to notify somebody responsible to take immediate action. \n\nReleased under BSD licence.  \nMikael Konttinen / Somewhat Original.\n\n----------\n\n## Table of contents\n- [Table of contents](#table-of-contents)\n- [Description](#description)\n- [Installation](#installation)\n- [Options](#options)\n- [Dictionaries](#dictionaries)\n- [Instance parsers](#instance-parsers)\n- [Instance helpers](#instance-helpers)\n- [Errati helpers](#errati-helpers)\n- [Final notes](#final-notes)\n- [Change log](#change-log)\n\n## Description\n\nStart with registering errors from a dictionary, either the provided http codes or a custom dictionary. Errati uses a singletonish pattern to have the indexed errors be consistently provided wherever required. Errors can be used interchangably as reference and/or instances.\n\nThe dictionary can be a Javascript Object or Array, depending on your preferences and needs. The dictionary specifies error codes, names, custom values and functions. All definitions are made by the order of generic to specific, meaning you can define values or functions for the entire dictionary and progressively override them for the class and the error instance.\n\nErrati adds a couple of helpers for common needs, all of which can be overridden. The helpers are toString(), toObject() and toJson(). You can easily add custom helpers in your desired scope. Errati also comes with internal parsers for instantiation arguments and stack traces, and a post-instantiation hook. All of these can also be overridden with custom functions.\n\nErrati comes with two dictionaries of HTTP Standard Codes. One \"short\" dictionary of most used HTTP Standard Errors, and one \"full\" dictionary of HTTP Standard Codes. Using one of these is optional, as is extending the index with custom dictionaries. Multiple dictionaries can be registered and separated in the index by prefixes.\n\nErrati aims to be as straightforward as possible. All registered Errors are Javascript functions that inherit the prototype from the Javascript Error. \n\nThe code is well documented in case you would need additional functionality that is not provided out of the box. \n\nTests are included to verify the functionality of Errati.\n\n\n----------\n\n## Installation\n```javascript\n\tnpm install errati\n\t\n\tapp.js:\n\t\tvar options = { /* ... */ };\n\t\tvar Errati = require('errati').setup( options );\n\t\n\tmyfile.js:\n\t\tvar Errati = require('errati');\n```\n\n...and you are ready to go. Note that you must call the .setup() function to initialize Errati. If no options are provided, the included \"http-short\" dictionary of the most common HTTP Standard Errors is loaded.\n\nTo load the \"http-full\" dictionary of HTTP Standard Codes, use the following options.\n```javascript\n\tvar options = { dictionary:'http-full' };\n\tvar Errati = require('errati').setup( options );\n\t\n\tconsole.log( Errati );\n\t// List of registered errors\n```\nNote that the HTTP dictionaries are not more than collections of standardized codes and names. You can use them for any desired application. \n\nAnd to load your custom list of errors:\n```javascript\n\tvar myErrors = { '101':'First error', '102':'Second error' };\n\tvar options = { dictionary: myErrors };\n\tvar Errati = require('errati').setup( options );\n\t\n\tconsole.log( Errati )\n\t// { FirstError: { [Function] _name: 'First error', code: '101' },\n\t//   SecondError: { [Function] _name: 'Second error', code: '102' } }\n\t\n\tconsole.log( Errati.FirstError );\n\t// { _name:'First error', code:'101' }\n\t\n\tconsole.log( new Errati.FirstError( 'This is a message') );\n\t// { name:'First error', code:'101', message:'This is a message' }\n```\nNote that 'name' is a reserved field for javascript functions, so error classes use the underscore prefixed field '_name' instead.\n\n----------\n\n\n## Options\n\nConfiguration of Errati is done by passing a configuration object (from here; 'options') to the Errati.setup() function. The options specify how the jointly passed [dictionary](#dictionaries) is parsed.\n\n\nThe options are divided in the following main parts:\n```javascript\n\tvar options = {\n\t  /* Defines the errors that are to be parsed and indexed */\n\t  dictionary: {},\n\t  \n\t  /* Defines how the errors are parsed and indexed */\n\t  fields: {\n\t\tmap: {}\n\t  },\n\t  reflow: '',\n\t  \n\t  /* Defines functionality for indexed errors */\n\t  extend: {},\n\t  override: {},\n\t  \n\t  /* Defines the functionality of Errati itself */\n\t  errati: {}\n\t};\n```\n\nOptions passed to Errati.setup() are a configuration for that particular dictionary. No changes are made to errors already indexed by Errati.\n\nThe only exception is the field [options.errati](#.errati) that adds functionality to Errati itself.\n\n\n\n### .dictionary\n\nA dictionary of Errors.\n```javascript\ndictionary:\t{}|[]|'http-short'|'http-full'|false\n```\n\n- **'http-short'**: Most common HTTP Errors (default)\n- **'http-full'**: Full set of HTTP Status Codes\n\nSee: [Dictionaries](#dictionaries).\n\n### .fields and .fields.map\nConfiguration of mapping and indexing of dictionary data.\n\n```javascript\nfields: {\n\t// Mapping\n\tmap: {\n\t\t_index: 'field1',\t\t// Dictionary indexes to field1\n\t\t_value: 'field2',\t\t// Dictionary string values to field2\n\t},\n\n\t// Indexing and prefixing\n\t'field1': true,\t\t\t\t// Index field1\n\t'field2': 'prefix1',\t\t// Index field2 with 'prefix1'\n\t'field3': {\t\t\t\t\t// Index field3 with 'prefix2'\n\t\tprefix: 'prefix2'\n\t},\n\n\t//'field4': false\t\t\t// Superfluous\n}\n```\n\n\nOptions.fields.map determines how the index and string values (not objects) from the dictionary are to be interpreted. The mapping uses two special fields, _index and _value, prefixed with an underscore to signify that they are not referring to the fields 'index' and 'value', but references to the dictionary.\n```javascript\ndictionary[ _index ] = _value\n```\nBy default, _index is set to 'code' and _value is set to 'name'. Hence with the default settings:\n```javascript\n\tvar options = {\n\t\tdictionary: { '100': 'My Error' }\n\t};\n\tErrati.setup( options );\n\t\n\tconsole.log( Errati );\n\t// { MyError: { _name: 'My Error', code: '100' } }\n\tconsole.log( Errati.MyError );\n\t// { _name: 'My Error', code: '100' }\n```\n\nSay we'd like to preserve the default mapping of dictionary index to the field 'code' but remap dictionary string values to 'title'. Also, we'd like to index the field 'code' and prefix it with 'code_'.\n```javascript\n\tvar options = {\n\t\tdictionary: { '100': 'My Error' },\n\t\tfields: {\n\t\t\tmap: {\n\t\t\t\t_value: 'title'\n\t\t\t},\n\t\t\t'code': 'code_'\n\t\t}\n\t};\n\tErrati.setup( options );\n\t\n\tconsole.log( Errati );\n\t// { code_100: { title: 'My Error', code: '100' } }\n\tconsole.log( Errati.code_100 );\n\t// { title: 'My Error', code: '100' }\n```\n\nWe can also map the dictionary index and values to something totally different:\n```javascript\n\tvar myErrors = { 'emergency': 'Tommy' };\n\tvar options = {\n\t\tdictionary: myErrors,\n\t\tfields: {\n\t\t\tmap: {\n\t\t\t\t_index: 'state',\n\t\t\t\t_value: 'blame'\n\t\t\t},\n\t\t\t'state': 'stateOf'\n\t\t}\n\t};\n\tErrati.setup( options );\n\n\tconsole.log( Errati );\n\t// { stateOfEmergency: { blame: 'Tommy', state: 'emergency' } }\n\tconsole.log( Errati.stateOfEmergency );\n\t// { blame: 'Tommy', state: 'emergency' }\n```\n\n\n### .reflow\nReflowing of error fields to be indexed to code friendly indexes.\n```javascript\nreflow:\t'CamelCase'|'underscore'|'nospace'|function|false\n```\n\n| Reflow     | 'error name '|\n|------------|--------------|\n| CamelCase  | 'ErrorName'  |\n| Underscore | 'error_name' |\n| Nospace    | 'errorname'  |\n\n\nExample of a custom function:\n```javascript\n\treflow: function( string ){\n\t\treturn string;\n\t}\n```\n\n\n### .extend\n\nExtending all errors in dictionary with fields and functions.\n```javascript\nextend: {\n\t// Extend all classes and instances with field\n\tmyField: 'value',\n\t\n\t// Extend all instances with function\n\tmyHelper: function(){\n\t\t/* this... */\n\t},\n\t\n\t// Custom function called after error instantiation\n\tinit: function(){\n\t\t/* this... */\n\t}\n},\n```\nAs all fields are populated in the order from generic to specific (Dictionary > Class > Instance), you can also add default values that are later specified per class or instance.\n\nFor example:\n```javascript\n\tvar myErrors = {\n\t\t'101': { name: 'Error One' \t},\n\t\t'102': { name: 'Error Two', message: 'Class message' }\n\t};\n\tvar options = {\n\t\tdictionary: myErrors,\n\t\textend: {\n\t\t\tmessage: 'Dictionary message'\n\t\t}\n\t};\n\tErrati.setup( options );\n\n\tconsole.log( Errati.ErrorOne.message );\n\t// Dictionary message\n\tconsole.log( Errati.ErrorTwo.message );\n\t// Class message\n\tconsole.log( new Errati.ErrorTwo('Instance message').message );\n\t// Instance message\n```\n\n\n#### .extend.init\nThere is also the \"hook\" options.extends.init (actually just a field) for a function to be run post instantiation of an error.\n\nThe init function takes no arguments, but is scoped to the instance, meaning you have the full instance with the keyword \"this\". Init follows the same chain of population, so you can define generic and custom init functions. Note that init is called at instantiation only.\n\nFor example:\n```javascript\n\tvar myErrors = {\n\t\t'101': { name: 'Error One' \t},\n\t\t'102': { \n\t\t\tname: 'Error Two',\n\t\t\tinit: function(){\n\t\t\t\tconsole.log( 'I am totally second:', this.toString() );\n\t\t\t}\n\t\t}\n\t};\n\tvar options = {\n\t\tdictionary: myErrors,\n\t\textend: {\n\t\t\tinit: function(){\n\t\t\t\tconsole.log( 'I am error:', this.toString() );\n\t\t\t}\n\t\t}\n\t};\n\tErrati.setup( options );\n\t\n\tnew Errati.ErrorOne();\n\t// I am error: Error One\n\tnew Errati.ErrorTwo();\n\t// I am totally second: Error Two\n```\n\n\n\n\n\n### .override\n\nOverriding default functions for error instances.\n```javascript\noverride:{\n\ttoString:function(){ /* this... */ return string; },\n\ttoObject:function(){ /* this... */ return object; },\n\ttoJson:function(){ /* this... */ return json; },\n\tparseArgs:function(args){ /* this... */ },\n\tparseStack:function(stacktrace){ /* this... */ this.stack = stacktrace }\n}\n```\n\nThe sections extend and override function in a near identical fashion, meaning options.override also populates from generic to specific, with the exception that functions in the options.override are already populated by default functions. The separation of these in to two fields is somewhat by principle but mostly for legibility.\n\nThese helper functions are also available for class use in the class prototype\n(Errati.MyError.prototype).\n\n\n### .errati\nThis section is for configuring Errati itself. Currently the only field is options.errati.extend that extends Errati with custom functions.\n\nFor example:\n```javascript\nerrati:{\n\textend: {\n\t\tgetNames:function(){\n\t\t\tvar names = [];\n\t\t\tfor( var key in this ){\n\t\t\t\tif( this.hasOwnProperty( key ) )\n\t\t\t\t\tnames.push( key );\n\t\t\t}\n\t\t\treturn names;\n\t\t}\n\t}\n}\n```\n\n---\n## Dictionaries\n\nThe dictionary can be either an Object or an Array, depending on needs and preferences.\n\n```javascript\n\tvar myErrors = [ 'First error', 'Second error', 'Third error' ];\n\t\n\tvar myErrors = {\n\t\t// Plain\n\t\t'101':'Error one',\n\t\t\n\t\t// Extends\n\t\t'102':{\n\t\t\tname: 'Error two',\n\t\t\tsome: 'value',\n\t\t\tmy: function(){ /* code */ }\n\t\t},\n\t\t\n\t\t// Overrides\t\t\n\t\t'103':{\n\t\t\tname: 'Error four',\n\t\t\tcode: '104',\n\t\t\ttoString: function(){ /* code */ }\n\t\t}\n\t}\n```\n\nErrati.setup() can be called multiple times for multiple dictionaries, sets with different values/functions and/or for some other structural divisions. \n\nBe sure to have unique indexes for all errors. Make use of prefixes ([see Fields](#.fields-and-.fields.map)) for different sets with identical error codes or names. Errati throws an error if you attempt to register duplicates with identical index.\n\n\n----------\n\n\n## Instance parsers\n\n### Arguments parser\n\nThe instatiation arguments parser aims to provide a flexible error constructor with the assumption that errors are commonly instantiated with a message.\n\nIt works by the following principles, in order:\n\n1. If the first argument is a String, it is the message.\n2. If the first argument is an Object with the field 'message', all its fields are merged to the instance.\n3. Additional arguments are passed to an array in the field 'args'.\n4. If the first argument is not a String and has no field 'message', all arguments are passed to the field 'args'.\n\nExamples:\n```javascript\n\tnew Errati.MyError( 'My message' );\n\t-> { name:'My Error', message:'My message', ... }\n\t\n\tnew Errati.MyError( 'My message', { some:'value' } );\n\t-> { name:'My Error', message:'My message', args:[{ some:'value' }], ...  }\n\t\n\tnew Errati.MyError( { message: 'My message', some:'value' } );\n\t-> { name:'My Error', message:'My message', some:'value', ... }\n\t\n\tnew Errati.MyError( { some:'value' }, { another:'value' } );\n\t-> { name:'My Error', args:[{some:'value'}, {another:'value'}], ... }\n```\nNote that the arguments parser sidesteps the regular Error instantiation behaviour. \n\nIf you wish to retain this, simply override the arguments parser with:\n```javascript\n\toverride: {\n\t\tparseArgs:function(){\n\t\t\tError.apply( this, arguments );\n\t\t}\n\t}\n```\n\n\n### Stack parser\n\nThe single purpose of the instantiation stack parser is to provide a stack trace that tops on where the error was instantiated. It simply removes the lines that refer to Errati from the stack trace.\n\nIt can be overridden as:\n```javascript\n\toverride: {\n\t\tparseStack:function( stacktrace ){\n\t\t\t/* do something */\n\t\t\tthis.stack = stacktrace;\n\t\t}\n\t}\n```\n\n----------\n\n## Instance Helpers\n\nInstanced errors have by default the following helper functions with the following behaviour. All of these can be [overridden with custom functions](#.override).\n\n### .toString()\n\nReturns a string representation that is limited to the error name and a colon separated message, if a such exists.\n\nExample:\n```javascript\n\tconsole.log( new Errati.MyError('I am message').toString() );\n\t// My error: I am string.\n\tconsole.log( new Errati.MyError() );\n\t// My error\n```\n\n\n### .toObject()\n\nParameters:\n\n\tfilters\t{ in:[] || ex:[] }  (optional)\n\n\nReturns a cloned object without the error prototype. Note that Errati returns a shallow (- only relevant if you want to work with the error instance or nested the values in intact form later).\n\nThis helper also has a simple filtering function for first level fields. The filtering is done either by including or excluding field names, but not both. Filtering is set by passing an Object with the fields 'in' or 'ex', containing an Array of field names to include or exclude.\n\nExamples:\n```javascript\n\tconsole.log( myError.toObject( { in:['name'] } ) );\n\t// { name:'My error' }\n\tconsole.log( myError.toObject( { ex:['name'] } ) );\n\t// { code:'100', some:'value' }\n```\n\n\n### .toJson()\n\nParameters:\n\n\tfilters\t{ in:[] | ex:[] }   (optional)\n\n\nThis is a wrapper for JSON.stringify that also applies the filtering function for toObject.\n\nExamples:\n```javascript\n\tconsole.log( myError.toJson( { in:['name'] } ) );\n\t// { \"name\":\"My error\" }\n\tconsole.log( myError.toJson( { ex:['name'] } ) );\n\t// { \"code\":\"100\", \"some\":\"value\" }\n```\n\n\n----------\n\n## Errati helpers\n\n### .toString()\n\nParameters:\n\n\ttabulator\tstring  (optional)\n\n\nThis helper returns a string representation of the Errati errorsIndex. You can pass a custom string for the tabulator. By default the tabulator is two spaces.\n\nExamples:\n```javascript\n\tconsole.log( Errati.toString() );\n\t// ErrorOne: {\n\t//   _name: \"Error One\",\n\t//   code: \"101\"\n\t// },\n\t// ErrorTwo: {\n\t//   _name: \"Error Two\",\n\t//   code: \"102\"\n\t// }\n```\n\t\n\n### .forEach()\n\nParameters:\n\n\tcallback\tfunction\n\targuments\t(optional)\n\nIterate through all registered errors. The callback should be formulated as:\n```javascript\nfunction( error, params ){}\n```\nAnd 'params' contain the following fields:\n\n- **index**: The errors indexing value\n- **errati**: The errati instance\n- **args**: An array of addtional arguments\n\nExample:\n```javascript\n\tErrati.forEach( function( err, params){\n\t\tconsole.log( params.args, params.index, err._name );\n\t}, 'Hello' );\n\t// [ 'Hello' ] 'ErrorOne' 'Error One'\n\t// [ 'Hello' ] 'ErrorTwo' 'Error Two'\n```\n\n\n### .count()\n\nParameters:\n\n\tprefix\tstring  (optional)\n\nCounts the number of registered errors. If a prefix string is provided, it returns the number of errors that starts with the provided string.\n\nExample:\n```javascript\n\tErrati.count();\n\t// 15\n\tErrati.count('dbs_');\n\t// 4\n```\n\n\n----------\n\n\n## Final notes\nTake a look at the examples directory and the code for in depth understanding of how Errati works. Some of you may find individual prototypes for errors classes an anti-pattern. I partly agree with this, but it was a conscious decision due to the following factors: \n\n1. Efficiency. Less lookup, less prototype chains to traverse. \n2. Legibility of code is largely improved by the current solution.\n3. The overhead is neglible. \n\nI know there be Javascript-fu to name dynamic functions (http://marcosc.com/2012/03/dynamic-function-names-in-javascript/), but them being eval'y hacks, I decided to stick with the _name field in error classes. Please let me know if you know of a better way to do this.\n\nI'm considering a plugin system to make Errati easier to extend with third party modules. Not sure if anyone would use it. Let me know if this would be a big improvement.\n\n\n---\n\n\n## Change log\n\n0.9.1  \nChanges to the README.md.  \nBumped version to adhere to NPM standards.\n\n0.9.0\nGoing public! Release candidate for version 1.0.0  \nDocumentation.  \nTests.  \n",
  "_id": "errati@0.9.1",
  "dist": {
    "shasum": "02cdb3f857e75bd0ceb3296dbc7f09fa055cc5f9",
    "tarball": "http://registry.npmjs.org/errati/-/errati-0.9.1.tgz"
  },
  "_from": "errati@*",
  "_npmVersion": "1.2.30",
  "_npmUser": {
    "name": "smwht_mkn",
    "email": "mikael@smwht.org"
  },
  "maintainers": [
    {
      "name": "smwht_mkn",
      "email": "mikael@smwht.org"
    }
  ],
  "_shasum": "02cdb3f857e75bd0ceb3296dbc7f09fa055cc5f9",
  "_resolved": "https://registry.npmjs.org/errati/-/errati-0.9.1.tgz"
}
